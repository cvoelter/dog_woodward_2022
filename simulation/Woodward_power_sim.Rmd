---
title: "Woodward experiment power simulation"
author: "Christoph VÃ¶lter"
date: "31/07/2023"
output: 
  html_document:
    theme: united
    toc: yes
    toc_depth: 4
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls(all.names = TRUE))
library(tidyverse)
# library(cowplot)
# library("gghalves")

load("power_sim_woodward_N19.RData")
```

## Generate data

```{r echo=FALSE, include=FALSE}
set.seed(1)
n.subject <- 20 # number subjects
n.per.subject <- 4 # observations per subject
n.per.condition <- 2 # observations per subject and condition (= agent condition)
subj.id <- as.factor(paste("subj", 1:n.subject, sep = "."))
#age_range <- c(12:130) # age range between 1 and 13 years
hand.per <- c(0.51, 0.65) # performance in hand condition
claw.per <- c(0.15, 0.29) # performance in claw condition

# add condition and trial number
start.data <- data.frame(subj.id = c(1:n.subject))
                         
start.data$order = rep(c("hand_hand_claw_claw", "claw_claw_hand_hand"), n.subject/n.per.subject)

start.data<- start.data %>%
  separate(order, c("1", "2", "3", "4"))%>%
  pivot_longer(cols=c("1","2","3","4"), names_to="trial", values_to="condition")%>%
  mutate(trial = as.numeric(trial))#%>%
 # mutate(first_condition = ifelse(trial == 1, condition, lag(first_condition)))

table(start.data$trial, start.data$condition)

start.data$trial_w_con<-rep(c(1:2), n.subject*n.per.condition)
start.data$first_condition<-rep(c(rep("hand_first",4), rep("claw_first", 4)), n.subject/2)

# z-transformation of covariates
start.data$z.trial <- as.vector(scale(as.numeric(start.data$trial_w_con)))

# dummy code factors
start.data$condition <- as.factor(start.data$condition)
start.data$condition.dummy <- as.numeric(start.data$condition == levels(start.data$condition)[2])


# center condition for random slopes:
start.data$condition.c <- as.numeric(start.data$condition) - mean(as.numeric(start.data$condition))

start.data<- start.data [1:76,]
table(start.data$condition, start.data$first_condition)


# checks:

xx <- table(start.data$subj.id, start.data$condition)
range(apply(X = xx > 0, MARGIN = 1, sum))

xx <- table(start.data$subj.id, start.data$trial)
range(apply(X = xx > 0, MARGIN = 1, sum))

```


## Simulation

```{r eval=FALSE, include=FALSE}
n.simus <- 1000 
r.effects <- c(0.9) # random effects to be simulated
# with the intercept being -0.9 (qlogis(0.29)) we could make the following
# guesses for the random intercept:
#- 0.4: moderate random intercepts effect


r.slope.con <- c(1.5, 3)
# with the intercept being -0.8 (qlogis(0.29)-qlogis(0.65)) we could make the following
# guesses for the random slope:
#- 0.9: moderate random slopes effect


#r.slope.trial <- 0.1


# create object to store the simulation parameters and results:
all.res <- data.frame(expand.grid(
  n.per.subject = n.per.subject, r.effect = r.effects, 
  r.slope.con = r.slope.con, r.slope.trial = r.slope.trial,   
  hand.per =  hand.per,
  claw.per = claw.per,
  simu = 1:n.simus
))
all.res$icpt <- NA
all.res$conditionhand <- NA
all.res$re.sd <- NA
all.res$warns.full <- NA
all.res$warns.null <- NA
all.res$lrt.p.con <- NA
all.res$lrt.p.trial <- NA
all.res$lrt.p.first.con <- NA
all.res$full.null.p <- NA

all.ests=matrix(NA, nrow=n.simus, ncol=1)
colnames(all.ests)=c("lrt.p.con")

# create data frame with design:
## done above

# load packages needed:
library(lme4)
# Loading required package: Matrix
library(kyotil) # we want to store info about convergence issues

# define control structure to make convergence more likely:
contr <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 10000))

xdata <- start.data


# run simulation
for (i in 1:nrow(all.res)) {

  set.seed(i) # allows to later replicate individual simulations

  # # add age  (if it should be generated in each loop)
  # age <- sample(x = age_range, size = length(unique(xdata$subj.id)), replace = T)
  # xdata$age <- as.numeric(age[as.numeric(xdata$subj.id)])
  # xdata$z.age <- scale(xdata$age)
  
  m.mat <- model.matrix(object = ~condition +  first_condition + z.trial , data = xdata) # create model martix

  coefs <- c(
  "(Intercept)" = log(all.res[i, "claw.per"] / (1 - all.res[i, "claw.per"])),
  "conditionhand" = log(all.res[i, "hand.per"] / (1 - all.res[i, "hand.per"] )) - log(all.res[i, "claw.per"] / (1 - all.res[i, "claw.per"])),
  "first_conditionhand_first" = 0,
  "z.trial" = 0
)
  
  LP <- m.mat[, names(coefs)] %*% coefs # LP wrt fixed effects

  # add random effect to linear predictor:
  LP <- LP + rnorm(n = n.subject, sd = all.res[i, "r.effect"])[as.numeric(xdata$subj.id)] +
    rnorm(n = n.subject, sd = all.res[i, "r.slope.con"])[as.numeric(xdata$subj.id)] * xdata$condition.c #+
#    rnorm(n = n.subject, sd = all.res[i, "r.slope.trial"])[as.numeric(xdata$subj.id)] * xdata$z.trial 

  # generate response:
  xdata$correct <- rbinom(n = nrow(xdata), size = 1, prob = exp(LP) / (1 + exp(LP)))

  # fit full model:
  full <- keepWarnings(glmer(correct ~ condition + first_condition + z.trial + (1 + condition.c || subj.id),
    data = xdata, family = binomial, control = contr
  ))
  # fit null model:
  null <- keepWarnings(glmer(correct ~ first_condition + z.trial + (1 + condition.c || subj.id),
    data = xdata, family = binomial, control = contr
  ))

  # store results:
  all.res[i, c("icpt", "conditionhand", "first_conditionhand_first",  "z.trial")] <- fixef(full$value)
  all.res[i, "re.sd"] <- as.data.frame(summary(full$value)$varcor)[1, "sdcor"]
  all.res[i, "warns.full"] <- nchar(paste(full$warnings, collapse = ""))
  all.res[i, "warns.null"] <- nchar(paste(null$warnings, collapse = ""))
  all.res[i, "lrt.p.con"] <- as.data.frame(drop1(full$value, test = "Chisq"))["condition", "Pr(Chi)"]
  all.res[i, "lrt.p.first.con"] <- as.data.frame(drop1(full$value, test = "Chisq"))["first_condition", "Pr(Chi)"]
  all.res[i, "lrt.p.trial"] <- as.data.frame(drop1(full$value, test = "Chisq"))["z.trial", "Pr(Chi)"]
  all.res[i, "full.null.p"] <- as.data.frame(anova(null$value, full$value, test = "Chisq"))[2, "Pr(>Chisq)"]
  print(i)
}

summary(full$value)
save.image("power_sim_woodward_N19.RData")
```

## Evaluation of results 

* number of warning per combinations of random effects (out of 1000 models per cell)  
Full model:  
```{r echo=FALSE}
#full model
tapply(X=all.res[, "warns.full"]>0, INDEX=all.res[, c("hand.per", "claw.per", "r.slope.con")],
FUN=sum)
#warning codes: 
#363: unable to evaluate scaled gradient. Model failed to converge: degenerate  Hessian with 1 negative eigenvalues
#205: Model is nearly unidentifiable: large eigenvalue ratio - Rescale variables?
```

Null model:  
```{r echo=FALSE}
#null model: 
tapply(X=all.res[, "warns.null"]>0, INDEX=all.res[, c("r.slope.con", "r.effect")],
FUN=sum)
```

* plotting the estimates (all models)

```{r echo=FALSE}
par(mar=c(3, 3, 0.2, 0.2), mgp=c(1.7, 0.3, 0), tcl=-0.15, las=1)
plot(
  x = as.numeric(as.factor(rep(
    x = c("icpt", "conditionhand", "re.sd"),
    each = nrow(all.res)
  ))),
  y = unlist(all.res[, c("icpt", "conditionhand", "re.sd")]),
  pch = 19, col = grey(level = 0.2, alpha = 0.2),
  xaxt = "n", xlim = c(0.5, 3.5), ylab = "estimate", xlab = ""
)
mtext(text = c("icpt", "conditionhand", "re.sd"), side = 1, at = 1:3, line = 0.2)
```

## Only models that converged are evaluated from here on:  

```{r include=FALSE}
all.res2=subset(all.res, warns.full==0)

table(round(all.res2$conditionhand))

```


### How many models converged, have a significant full-null model comparison, and a significant LRT of condition?  
```{r echo=FALSE}

lrt.data2 <- all.res2 %>%
  filter(full.null.p<0.05)%>%
  group_by(claw.per, hand.per, r.effect, r.slope.con) %>%
  summarise(condition=mean(conditionhand),
            first_condition=mean(first_conditionhand_first),
            z.trial=mean(z.trial),
            lrt.p.con.mean = mean(lrt.p.con), 
            lrt.p.trial.mean = mean(lrt.p.trial), 
            lrt.p.first.con.mean = mean(lrt.p.first.con), 
            n.sign.lrt2 = length(lrt.p.con[lrt.p.con < 0.05]), 
            n.lrt = n.simus,#length(lrt.p.con), 
            proportion.sign.lrt.con = length(lrt.p.con[lrt.p.con < 0.05]) / n.simus,
            proportion.sign.lrt.trial = length(lrt.p.trial[lrt.p.trial < 0.05]) / n.simus)

lrt.data2
write.table(lrt.data2, file = "post_hoc_power_table.txt", sep = ",", quote = FALSE, row.names = T)
```

#### Plotting the proportion of significant LRTs for the predictor variable condition ONLY based on models that converged and with a significant full-null model comparison

```{r echo=FALSE}

p.con.power <- ggplot(data = lrt.data2, aes(y=proportion.sign.lrt.con, x=as.factor(hand.per)))+
        geom_boxplot( aes(x=as.factor(hand.per), y=proportion.sign.lrt.con, color=as.factor(claw.per)),  width=0.3)+
      ylim(0.0, 1)+
  geom_hline(yintercept = 0.8, colour = "black", lwd = 1.05, lty = 3) +
      ylab("Power") +
      xlab("Hand condition performance") +
   scale_color_manual(name="Claw condition", values=c("darkorange", "dodgerblue"))+
  facet_wrap(~r.slope.con)+
      theme_bw()
 p.con.power

ggsave( p.con.power, filename = "woodward_power.png", scale = 0.5, height = 8, width = 9)
```
